# Raft Based Distributed cache
基于Raft论文实现的,github有个中文的[Raft中文翻译版本](https://github.com/maemual/raft-zh_cn)<br>
翻译的很准,不过简化了好多,感觉还是英文的比较好,英文的读的慢思考时间更多。<br>
学习用的应该有bug的,包括查资料,写代码,测试用了大概十多天的样子吧<br>
整体思路就是由Raft算法维持集群状态的一致性（节点丢失，增加问题）
一致性hash将数据分散到各个节点上(搞不懂为啥很多做缓存的,还要让集群缓存数据一致,个人感觉缓存的系统压力主要在内存上，其次才是客户端连接的压力)


# 支持的功能
* leader选举
* 集群成员动态更变,保证集群半数以上server活着,依然能对外提供服务
* 基于一致性hash保证缓存数据的负载均衡
* 客户端连接server基于随机算法,保证每台server连接的client负载均衡
* 缓存数据的备份(内存快照+写操作的日志 = 完整缓存数据)


# 技术点
* Raft算法
* 一致性hash
* NIO(处理客户端请求是基于nio) 
* 并发编程


# Quick Start
* chmod -R 777 cache-example/
* cd cache-example
* ./build.sh 5    可以快速在本机上部署五个实例的集群(必须写正常的参数,shell脚本不太会,没处理异常的)
* ./kill_all.sh 5 可以关闭这五台集群(必须正确的参数)
* ./kill.sh 1     可以关闭id = 1 的一个实例(必须正确的参数)
* ./start.sh 1    可以开启id = 1 的一个实例(必须正确的参数)
* ./client.sh 127.0.0.1:9091 可以连接集群中指定实例，不写参数的的话会随机选择一台
* 反复创建(执行build.sh) 而没有对应关掉的话,自己jps 查看下手动kill
* build.sh 之后一定要有kill，才能再build,pid文件存在创建实例的时候会自己退出

# 程序运行流程
* load node 
* load snaphot 
* load raft logs
* 加载缓存备份数据，恢复到之前的状态
* init thread pool
* 启动监听其它节点消息的线程
* 启动监听客户端的消息的线程


# 总结(遇到的坑)
* lock.lock() 一定要在finally里面unlock 释放锁，状态转换的时候可能会中断该线程，导致锁没有释放
    最后其他线程无限等待状态
* lock 里面不要放io这种耗时操作，io 阻塞后的线程切换并不会释放锁，切换别的线程拿不到锁，也是白搞
* 本来是用map维护socket连接的，最后自己粗心了，创建socket之后没有put进去,导致监听该socket连接的server
    创建过多连接，导致线程池线程耗完，无法处理后续连接
* 考虑所有的情况，不要在编码的时候合并流程（即使该流程是不会发生的）,可以在编码完成后再合并
* NIO这块网上的demo基本没有能直接跑的,cpu跑满的,不管数据有多大，直接往buffer里面扔,发送给客户端也有

# 从数据一致性到系统架构的认识(猜想)
以前我总觉的mysql 这种主从复制集群模式,跟单机没啥区别,因为数据需要同步,主服务器写入的数据还是会到达从服务器<br>
这种集群能提供的性能跟单机差不多.现在自己实现了下,一致性算法,更能明显感觉到,需要提供数据一致性的功能集群(特别是对一致性要求高的)服务器
他能提供的最大性能是单机的k倍(k值可能就是2,3 这种小数字),不像web之类的服务器,它可以一直扩展下去,最后整个服务器集群提供的性能线性上升
所以这导致了随着用户的增加,整个系统的压力瓶颈会在mysql这里,所以后面出现了缓存,消息队列等就是为了避免大量请求到mysql数据库,导致数据库的崩溃.
为了将需要维护的一致性数据量减少,采用分库的形式,就是让每个mysql集群维护一部分的数据,每个集群之间没有数据交叉.
根据功能,服务拆分整个系统的数据库,就进一步演变成了,现在微服务的架构模式.
分库,或者微服务架构最后出现了新的问题,分布式事務<br>
......


